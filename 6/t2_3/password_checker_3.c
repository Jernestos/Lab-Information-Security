#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#define MIN(a,b) (((a)<(b))?(a):(b))
#define ADD(a,b) (a + b)

/*
The correct password in this file is padded with dollars ($) on both sides using the following
scheme: the first 15 − l $s followed by l characters of the correct password, followed by 15 − l
$s. For example, if the correct password is magicbeans, the file will contain
$$$$$magicbeans$$$$$
*/

int check_password_det(char* p,  char* i) {
	//int i_size == 15
	//int p_size == 15
	int return_value = 1;
	for(int pos = 0; pos < 15; ++pos) {
		return_value = return_value & (p[pos] == i[pos]);
	}
	//fprintf(stderr, "result: %d\n", return_value);
	return return_value;
}

int check_password(char* p, int p_size,  char* i, int i_size) {

	int max_length = MIN(p_size, i_size); //only check till the end of the smallest string
	int pos = 0;
	int j, k = 0;
	char distance = 0;

	for (pos = 0; pos < max_length; pos++)	{
		if (p[pos] == i[pos]) {
			k++;
		}
		else {
			//calculate the wrap-around difference between the password char and the input char. e.g., b->a = 1, a->b = 25
			distance = (p[pos] - i[pos]);

			if (distance < 0) {
				distance = 26 + distance;
			}
		
			for (j = distance; j > 0; j--) {
				ADD(p[pos], i[pos]);
			}
		}	
	}

	if (p_size == i_size && k == p_size)
		return 1;
	else 
		return 0;

}

/*
The initial password_checker_3.c was written to work for passwords without the dollar padding ($$$$). Because the run_tracer.py creates password files with padding, the functionality with the initial binary will always be wrong. Please use the description of the inputs and outputs from Section 3.3 of the task handout. Your solution should pass the functionality tests.
*/

/*
Concretely, the traces generated by SGXTrace in Section 2.4 should be the same for all
pairs of guesses of the same length and correct passwords of any length. For example,
traces for the pairs of guess and correct passwrords (magic, magicbeans), (qwert, qwerty),
and (pawnd, magic) should be identical because all guesses are 5 characters long. The traces
for (qwerty, qwerty), (magicbeans, magic),
*/

//assumptions: password only has small characters [a, z], maximum length is 15 characters
int main (int argc, char* argv[])	{

	if (argc != 3) {
		fprintf(stderr, "Usage: %s <password guess> <output_file>\n", argv[0]);
		exit(EXIT_FAILURE);
	}


	FILE* password_file;
	char password [16] = "\0";
	
	size_t len = 0;
	char* line;
	password_file = fopen ("/home/isl/t2_3/password.txt", "r");

	if (password_file == NULL) {
		perror("cannot open password file\n");
		exit(EXIT_FAILURE);
	}
	
	//https://www.geeksforgeeks.org/c-program-to-read-contents-of-whole-file/
	//https://stackoverflow.com/questions/60882801/character-by-character-reading-from-a-file-in-c
	//https://www.tutorialspoint.com/c_standard_library/c_function_fseek.htm
	//fgetc: needs loop; 15 iterations for all password sine $ padded
	//fgets: need to account for null byte -> need password [17]
	//fscanf: no control over how many bytes to be read
	//fread: one liner;, can specify number of bytes to read
	//Moodle: getline; https://riptutorial.com/c/example/8274/get-lines-from-a-file-using-getline--
	//-> fgetc vs fread vs getline vs scanf
	
	//We don't know the password string length in advance due to padding
	//But we do know that the first part starts with 15 - l $, followed by l characters
	//hence 15 characters in total before another padding
	//-> cannot use fscanf nor getline since no size specficiation
	//fscanf(password_file, "%s", password); //here?
	
	
	for(int i = 0; i < 15; ++i) { //AAAAAAAAAAAAAAA\0
		password[i] = fgetc(password_file);
	}
	
	//fread(password, 1, 15, password_file);
	
	//getline(&password, &len, password_file); //uses internally getc
	
	
	
	//prepend and append $s
	char* password_attempt_unpadded = argv[1];
	char password_attempt_padded[16] = "$$$$$$$$$$$$$$$\0";
	size_t password_attempt_len = strlen(password_attempt_unpadded);
	size_t offset = (15 - password_attempt_len);
	
	for(int i = offset; i < 15; i++) {
		password_attempt_padded[i] = password_attempt_unpadded[i - offset];
	}
	
	
	
	
	int is_match = 0; 
	//is_match = check_password(password, strlen(password), argv[1], strlen(argv[1])); //here?
	//fprintf(stderr, "password: %s - %ld\n attempt: %s - %ld\n", password, strlen(password), password_attempt_padded, strlen(password_attempt_padded));
	is_match = check_password_det(password, password_attempt_padded);
	

	FILE* output_file;
	output_file = fopen (argv[2], "wb");
	fputc(is_match, output_file);
	fclose(output_file);

	fclose(password_file);
	return 0;
}