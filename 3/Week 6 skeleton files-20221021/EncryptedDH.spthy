theory EncryptedDH
begin

/* Signed Diffie-Hellman protocol, first attempt:
   A -> B : A, aenc_B{g^x}  (x fresh)
   B -> A : B, aenc_A{g^y, h(g^x)}  (y fresh)
   A -> B : A, aenc_B{h(g^y)}  */


/* ----------------- */
/* Equational theory */
/* ----------------- */

/* Load the built-in Diffie-Hellman, asymmetric encryption and hashing equational theories */
builtins: diffie-hellman, asymmetric-encryption, hashing



/* ------------------ */
/* Key infrastructure */
/* ------------------ */

rule GenKey:  // generate long-term key pair, publish the public key
   [ Fr(~kA) ] 
   -->
   [ !Key($A, ~kA),  // notation: !Fact = persistent fact, not consumed by rules
     !Pk($A, pk(~kA)),
     Out(pk(~kA)) ]


/*----------------*/
/* Protocol rules */
/*----------------*/

/* Question 1 here */

rule Init_1:
   let gxI = 'g'^~xI 
       enc_gxI = aenc(gxI, pkB)
   in  
      [!Pk($B, pkB), Fr(~xI)]
      -->
      [Init_1($A, ~xI, gxI), Out(<$A, enc_gxI>)]


rule Resp_1:
   let dec_gx = adec(enc_gx, ~kB)
       hash_dec_gx = h(dec_gx)
       gyR = 'g'^~yR
       kR = dec_gx^~yR
       tuple = <gyR, hash_dec_gx>
       enc_tuple = aenc(tuple, pka)
   in
      [In(<a, enc_gx>), !Pk(a, pka), !Key($B, ~kB), Fr(~yR)]
      --[RunningR(a, $B, kR)]->
      [Resp_1($B, ~yR, gyR, dec_gx, kR), Out(<$B, enc_tuple>)]


rule Init_2:
   let dec_tuple = adec(enc_tuple, ~kA)
       dec_gy = fst(dec_tuple)
       dec_hash_gx = snd(dec_tuple)
       hash_dec_gy = h(dec_gy)
       kI = dec_gy^~xI
       enc_hash_gy = aenc(hash_dec_gy, pkb)
   in
      [Init_1($A, ~xI, gxI), !Pk(b, pkb), In(<b, enc_tuple>), !Key($A, ~kA)]
      --[Eq(dec_hash_gx, h(gxI)), FinishedI($A), SecretI($A, b, kI), RunningI($A, b, kI), CommitI($A, b, kI)]->
      [Init_2($A, ~xI, gxI, dec_gy, kI), Out(<$A, enc_hash_gy>)]



rule Resp_2:
   let dec_hash_gy = adec(enc_hash_gy, ~kB) in    
      [Resp_1($B, ~yR, gyR, gx, kR), In(<a, enc_hash_gy>), !Key($B, ~kB)]
      --[Eq(dec_hash_gy, h(gyR)), FinishedR($B), SecretR(a, $B, kR), CommitR($B, a, kR)]->
      [Resp_2($B, ~yR, gyR, gx, kR)]

/* ---------- */
/* Key Reveal */
/* ---------- */

/* Question 2 here */
/* Omit this attack and the we have key secrecy established */
/*
rule q2_attack:
   [!Key(A, k)]
   --[Compromised(A)]->
   [Out(<A, k>)]
*/

/* ---------- */
/* Restrictions */
/* ---------- */

restriction equality:
"All x y #i. Eq(x,y) @i ==> x = y"


/* ---------- */
/* Properties */
/* ---------- */

/* Executability checks */
lemma executableI:
exists-trace "Ex #i A. FinishedI(A) @ i & not (Ex #j B. Compromised(B)@j)"

lemma executableR:
exists-trace "Ex #i B. FinishedR(B) @ i & not (Ex #j B. Compromised(B)@j)"


/* Key secrecy:  (Question 3)
   in all traces, if a key is marked as secret between two uncompromised agents,
   then the attacker cannot learn it */

lemma key_secrecyI:
"All #i A B k.
 (SecretI(A, B, k) @ i &
  not ((Ex #l. Compromised(A) @ l) | (Ex #m. Compromised(B) @ m)))
  ==> not (Ex #j. K(k) @ j)"

lemma key_secrecyR:
"All #i A B k.
 (SecretR(A, B, k) @ i &
  not ((Ex #l. Compromised(A) @ l) | (Ex #m. Compromised(B) @ m)))
  ==> not (Ex #j. K(k) @ j)"



/* Key agreement:  (Question 4)
Please uncomment the following two lemmas for this question.
*/



lemma agreementR:
"All #i A B k.
  (CommitR( B, A, k) @ i &
   not ((Ex #l. Compromised(A) @ l) | (Ex #m. Compromised(B) @ m)))
   ==> (Ex #j. RunningI(A, B, k) @ j & j < i)"


lemma agreementI:
"All #i A B k.
  (CommitI(A, B, k) @ i &
   not ((Ex #l. Compromised(A) @ l) | (Ex #m. Compromised(B) @ m)))
   ==> (Ex #j. RunningR(B, A, k) @ j & j < i)"


end



